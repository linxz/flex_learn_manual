import{_ as n}from"./01-2.f38143c4.js";import{_ as a,r as c,o as r,c as d,b as e,e as o,w as i,d as l,a as s}from"./app.8a7fda1c.js";const f="/flex_learn_manual/image/02-1.png",x="/flex_learn_manual/image/02-2.png",_="/flex_learn_manual/image/02-3.png",u="/flex_learn_manual/image/02-4.png",m={},h=e("h1",{id:"📕-属性介绍",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#📕-属性介绍","aria-hidden":"true"},"#"),l(" 📕 属性介绍")],-1),p=e("p",null,[l("在 flex 弹性布局中，涉及到属性主要是父元素以及其子元素的相关属性，按照这个特性，我们可将 flex 弹性布局相关属性分为 "),e("strong",null,"flex 容器"),l("和 "),e("strong",null,"flex 元素"),l("两个类别。")],-1),g=e("h2",{id:"flex-容器相关属性",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#flex-容器相关属性","aria-hidden":"true"},"#"),l(" flex 容器相关属性")],-1),w=e("p",null,"容器层的相关属性，顾名思义，就是指包含着内容的一个“器皿”，简单来说，也就是 flex 弹性布局的父级元素所拥有的属性，主要有：",-1),b=e("p",null,"这几个属性就是的作用就是声明当前元素是 flex 弹性布局的容器层，以及控制该容器中各个元素的显示方式。具体的后面会逐一介绍。",-1),y=e("h2",{id:"flex-元素相关属性",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#flex-元素相关属性","aria-hidden":"true"},"#"),l(" flex 元素相关属性")],-1),k=e("p",null,"所谓元素是相对于容器而言的，主要是指在一个具有 flex 弹性布局特性的容器中的所有子元素，在该容器中能够改变自身的相关属性以满足 flex 弹性布局。元素相关属性主要有：",-1),S=s('<p>其实主要就是 <code>flex</code> 、 <code>align-self</code> 和 <code>order</code> 这三个属性， <code>flex-grow</code> 、 <code>flex-shrink</code> 和 <code>flex-basis</code> 是可以简写为 <code>flex</code> 的，具体的后面我们再逐一介绍。</p><h2 id="flex-布局中的轴" tabindex="-1"><a class="header-anchor" href="#flex-布局中的轴" aria-hidden="true">#</a> flex 布局中的轴</h2><p>在后面开始逐一介绍每个 flex 属性之前，我们首先了解一下，在 flex 布局中所存在的一个叫做“轴”的概念。</p><p>在 flex 布局中的“轴”是由“主轴（main axis）”和“交叉轴（cross axis）”这两根轴组成，“主轴”是根据 <code>flex-direction</code> 而定，“交叉轴”则是垂直于“主轴”的那根。由于“主轴”是随 <code>flex-direction</code> 的值而变化位置，可能是横向的，也有可能是纵向的；但无论是哪个方向，“交叉轴”必定是垂直于“主轴”的那根。</p><img src="'+f+'" alt="image" style="zoom:50%;"><p>如上图所示，当我们选择使用 <code>flex-direction: row;</code>的时候，“主轴”的位置是横向的。而如下图所示，当我们使用 <code>flex-direction: column;</code> 的时候，“主轴”的位置就是纵向的了。但无论主轴是在什么位置，“交叉轴”必定是相对垂直于“主轴”而存在的。</p><img src="'+x+'" style="zoom:50%;"><p>在 flex 弹性布局中，理解“主轴”和“交叉轴”的概念是有必要的，因为后面在所提到的对齐 flex 元素时，基本上就是相对于“主轴”和“交叉轴”这两条轴线而实现的。比如水平垂直居中一个元素，那么就是让 flex 元素相对于“主轴”和“交叉轴”的中间位置对齐。</p><h2 id="flex-布局中的-起始线-和-终止线" tabindex="-1"><a class="header-anchor" href="#flex-布局中的-起始线-和-终止线" aria-hidden="true">#</a> flex 布局中的“起始线”和“终止线”</h2><p>在 CSS 布局中，<strong>一般情况</strong>的书写模式主要是被认为水平方向，且从左到右。从左开始的位置，就是平时我们使用 CSS 布局时的“起始线”，直到换行的位置就是“终止线”了，如果出现换行，那么新的一行就会出现这行的下面。</p><p>而对于我们现在所说的 flex 弹性布局，鉴于弹性的概念，灵活多变，就不再以上下左右的方式来标明 flex 容器的“起始线”和“终止线”了。</p><p><img src="'+n+'" alt="image"></p><p>以这张图为例，代码所展示的环境是中文以及仅仅设置了 <code>display: flex;</code> 在父级元素，因此现在的“起始线”是在红色的 1 这边，然后按照中文的书写习惯往右过去，到最后的黑色 0 结合，也就是到了“终止线”。</p><p>在这里提到两个因素影响点：</p><ul><li>语言环境：最为明显的是阿拉伯文，是从右到左，英文以及中文是从左到右。当然，也可以通过 <code>direction</code> 来改变文本显示方向，这就是另外一个话题了；</li><li><code>flex-direction</code>：在 flex 弹性布局中，我们可以通过设置 flex 容器中的 <code>flex-direction</code> 随时改变其 flex 元素的方向，也就是改变“轴”，一旦“轴”被改变之后，那么在 flex 布局中的“起始线”和“终止线”也将随之改变；</li></ul><p>为了能够更好地理解记忆这所谓的“起始线”和“终止线”，我们其实可以这么理解，在 flex 弹性布局中，只要第一个元素出现的位置，那么“起始线”必然是在这个元素的旁边，具体是在哪一边，那么就看第二个元素从哪个位置开始出现。</p><img src="'+_+'" alt="image" style="zoom:50%;"><p>如图所示，当我们改变了元素 1 的位置时，“起始线”的位置也将随之改变。那么如果我们这个时候将 flex 弹性布局的方向改为行（column）的话，“起始线”的位置也将随之变化，如下图所示：</p><img src="'+u+'" style="zoom:50%;"><p><strong>所以简单来说，第一个 flex 元素从哪里开始，那么“起始线”就从哪里开始，“终止线”的位置将会根据 <code>flex-direction</code> 最终的属性值而变化，也就是 flex 元素排列顺序的方向而决定“终止线”的位置。</strong></p>',20);function z(C,N){const t=c("RouterLink");return r(),d("div",null,[h,p,g,w,e("ul",null,[e("li",null,[o(t,{to:"/articles/container/display.html"},{default:i(()=>[l("display")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/flex-direction.html"},{default:i(()=>[l("flex-direction")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/flex-wrap.html"},{default:i(()=>[l("flex-wrap")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/flex-flow.html"},{default:i(()=>[l("flex-flow")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/justify-content.html"},{default:i(()=>[l("justify-content")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/align-items.html"},{default:i(()=>[l("align-items")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/align-content.html"},{default:i(()=>[l("align-content")]),_:1})]),e("li",null,[o(t,{to:"/articles/container/gap.html"},{default:i(()=>[l("gap")]),_:1})])]),b,y,k,e("ul",null,[e("li",null,[o(t,{to:"/articles/element/flex-grow.html"},{default:i(()=>[l("flex-grow")]),_:1})]),e("li",null,[o(t,{to:"/articles/element/flex-shrink.html"},{default:i(()=>[l("flex-shrink")]),_:1})]),e("li",null,[o(t,{to:"/articles/element/flex-basis.html"},{default:i(()=>[l("flex-basis")]),_:1})]),e("li",null,[o(t,{to:"/articles/element/flex.html"},{default:i(()=>[l("flex")]),_:1})]),e("li",null,[o(t,{to:"/articles/element/align-self.html"},{default:i(()=>[l("align-self")]),_:1})]),e("li",null,[o(t,{to:"/articles/element/order.html"},{default:i(()=>[l("order")]),_:1})])]),S])}const B=a(m,[["render",z],["__file","introduce.html.vue"]]);export{B as default};
