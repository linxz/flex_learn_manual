import{_ as n,o as s,c as e,a}from"./app.8a7fda1c.js";const l="/flex_learn_manual/image/02-01-1.png",i="/flex_learn_manual/image/02-01-2.png",p="/flex_learn_manual/image/02-01-3.png",c="/flex_learn_manual/image/02-01-4.png",o="/flex_learn_manual/image/02-01-5.png",d="/flex_learn_manual/image/02-01-6.png",t="/flex_learn_manual/image/02-01-7.png",u={},r=a(`<h1 id="📕-flex-容器-display" tabindex="-1"><a class="header-anchor" href="#📕-flex-容器-display" aria-hidden="true">#</a> 📕 flex 容器：display</h1><h2 id="初见-display-flex" tabindex="-1"><a class="header-anchor" href="#初见-display-flex" aria-hidden="true">#</a> 初见 display: flex;</h2><p>其实大家对于 <code>display</code> 属性并不陌生，并且也都是一直在使用，比如 <code>display: block;</code> 等，但这里我们所要说的是在 flex 弹性布局中所用到的：</p><ul><li><code>display: flex;</code></li><li><code>display: inline-flex;</code></li></ul><p>无论我们将 <code>display</code> 的属性值设置为 <code>flex</code> 还是 <code>inline-flex</code> ，都会将其自身转为 flex 容器，同时该元素的直系子元素将直接转为 flex 元素。在 CSS 中的，所有的属性都是有默认的属性值，当 flex 容器和 flex 元素创建之后，也就代表这个 flex 容器下的所有 flex 元素会拥有以下特性：</p><ul><li>元素排列成一行；</li><li>元素从主轴的“起始线”开始排列；</li><li>元素会被拉伸来填充交叉轴的大小；</li><li>元素不会在主轴上被拉伸，但是会缩小到自身内容所能容下的尺寸；</li></ul><p>以上只是从表面情况而看到的现象，其实在浏览器中对于每个 HTML 元素都是有相对应的一些 CSS 属性值，而当我们把某个父级元素的 <code>display</code> 特性改变之后，随之也就影响了其子元素的一些特性。在 flex 弹性布局中，我们所改变的父级元素转变为 flex 容器，其直系子元素则转为 flex 元素。因此，在 flex 容器中的所具有的 flex 属性也就产生了作用，得到的结果也就是我们在浏览器中所看到的效果。</p><p>🌰 简单举个例子：</p><blockquote><p>我们已知 <code>.demo</code> 中已经设置了 <code>display: flex;</code> 属性，那么这个时候 flex 容器所包含的 10 个 flex 元素都已经是触发了前面我们说提到的特性。因此，我们给 <code>.demo</code> 增加点样式，便于更好识别。</p><ul><li>有高度，那么 flex 元素就会随着“交叉轴”而拉伸；</li><li>无宽度，那么 <code>.demo</code> 的宽度就是浏览器的可见区域宽度；</li><li>添加 <code>padding</code> 可透出背景色，同时与边框产生间距，便于我们更容易识别；</li></ul></blockquote><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token comment">/* 
  file: flex_0001.css
  为了能够更好地体现 flex 元素在 flex 容器中的默认变化，
  我们添加高度以及内间距，同时增加边框和背景色，
*/</span>
<span class="token selector">.demo</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #d8d8d8<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px dashed #000<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么最终的效果就是 <a href="../../demo.html?id=1">demo_1</a> 这样了，与前面提到的表现形式是完全匹配的。</p><img src="`+l+`" style="zoom:50%;"><h2 id="再看-display-inline-flex" tabindex="-1"><a class="header-anchor" href="#再看-display-inline-flex" aria-hidden="true">#</a> 再看 display: inline-flex;</h2><p>现在我们看到的是 <code>display: flex;</code> 的一个表现结果，在前面提到过，<code>display</code> 在 flex 弹性布局中有两个属性值，那么还有一个 <code>inline-flex</code> 的属性值，会有什么表现效果呢？</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token comment">/* 
  file: flex_0002.css
  改变 .demo 的 display 属性值为 inline-flex
*/</span>
<span class="token selector">.demo</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-flex<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #d8d8d8<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px dashed #000<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 CSS 代码中可以看到，我们现在只是比之前多了一句 <code>display: inline-flex;</code>，也就是说我们把 <a href="../../demo.html?id=2">demo</a> 中默认的 <code>display</code> 属性值改变了，现在看到的页面效果会怎么样呢？</p><img src="`+i+'" style="zoom:50%;"><p>很明显可以感到两者的差异。当使用了 <code>inline-flex</code>后，就犹如我们使用了 <code>inline-block</code> 一样，不再是占据满满的一栏了，而是随着内容实际尺寸来改变。假如这个时候我们有两个 <code>.demo</code> 的 flex 容器，并且浏览器的宽度足够容纳得下，那么我们可以看到的效果就是这样了。</p><img src="'+p+`" style="zoom:50%;"><p>看着感觉既然那么像 <code>inline-block</code> 的表现，那么我们可以试着改变一下第二个 flex 容器的高度，然后再改变一下对齐方式会怎么样呢？</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.demo + .demo</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改变了第二个 <code>.demo</code> 的高度，然后再改变 <code>vertical-align</code> 的值，最后我们得到的结果就会是这样了：</p><img src="`+c+`" style="zoom:50%;"><p>从这结果来看，这两个 .demo 的对齐方式已经产生变化了，就跟 <code>inline-block</code> 的两个元素对齐方式相似，我们可以通过改变 <code>vertical-align</code> 的值观察两个元素的变化，再结合同一个 HTML 结构中 <code>inline-block</code> 的布局结果进行对比。</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token selector">.demo</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+o+`" style="zoom:50%;"><p>除了内部的子元素表现结果不同，其他的目前是没看到差异。所以，对于 <code>inline-flex</code> 这个属性值，我们可以这么理解：<strong>它是一个可以创建 flex 弹性布局的，且类似于 <code>inline-block</code> 的属性值</strong>。</p><p>虽然我们现在是大概了解了 <code>inline-flex</code> 这个属性值，但是在目前实际项目运用中，很少会有人去考虑使用这个属性值，而是更多地在 HTML 中嵌套一层，定义为 <code>display: flex;</code> 后再通过 flex 弹性布局的对齐方式来操作。感觉上是绕了一个弯路来实现了一个效果，但是条条道路通罗马，在 CSS 的世界中，一个页面布局效果可能会有 N 中实现方式。如何选择一种相对于当前项目相对较为合适的方式，这个是需要通过不断摸索总结，无法通过三言两语来描述。</p><h2 id="display-后-flex-元素的数量" tabindex="-1"><a class="header-anchor" href="#display-后-flex-元素的数量" aria-hidden="true">#</a> display 后 flex 元素的数量</h2><p>我们选择使用 <code>display: flex;</code> 还是 <code>display: inline-flex;</code> ，就好像我们在选择使用 <code>display: block;</code> 还是 <code>display: inline-block;</code> 一样，这都不是关键，反正可以很明确的一点就是，无论是 <code>flex</code> 还是 <code>inline-flex</code>，最终都是创建了 flex 容器，有了 flex 弹性布局的特性。</p><p>前面提到，当创建了 flex 容器之后，其直系子元素都将是 flex 元素，那么按照我们约定的 Demo 的 HTML 结构来看，仅仅只有这 10 个 div 标签是 flex 元素吗？如果，你的答案是肯定，仅仅只有这 10 个 flex 元素的话，那么，我想说，难道你们忘了 <code>::before</code> 和 <code>::after</code> 这两个伪元素了吗？</p><p>先不要急着否定哦，虽然这两个伪元素是需要通过 CSS 去“激活”的，但并不能否认这两个伪元素的存在，对吧？</p><p>为什么要提到这两个伪元素呢？</p><p>这是因为现在很多人都会去使用 iconfont 方式插入 icon，那么使用 iconfont 方式插入 icon 的话，是不是就先去考虑 <code>::before</code> 和 <code>::after</code> 这两个伪元素？如果考虑了，也就是要去“激活”伪元素了，最终不也就是多了一个 flex 元素了？</p><p>多了一个 flex 元素又能怎么样呢？</p><p>其实并不会怎么样，只是可能会影响到你的页面布局。在 flex 弹性布局时，仅仅只有一行可能不会有太多感受，但是有多行的话，情况就会有所不同了。</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token comment">/* 
  file: flex_0003.css
  未激活伪元素之前的多行 flex 弹性布局
*/</span>
<span class="token selector">.demo</span> <span class="token punctuation">{</span>
  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #d8d8d8<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px dashed #000<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> 1 1 20%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在未将伪元素内容提出来之前，我们现在看到的<a href="../../demo.html?id=3">页面</a>布局结构是这样的：</p><img src="`+d+`" style="zoom:50%;"><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code><span class="token comment">/* 
  file: flex_0004.css
  添加伪元素之后的多行 flex 弹性布局
*/</span>
<span class="token selector">.demo</span> <span class="token punctuation">{</span>
  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #d8d8d8<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px dashed #000<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> 1 1 20%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.demo::before,
.demo::after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">&#39;伪元素&#39;</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #cf197d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在之前的基础上，我们把<a href="../../demo.html?id=4">伪元素提出来</a>，那么情况就变了。至少新增的伪元素是不会有之前我们设定的 <code>.item</code> 的样式，除非重新定义一次。所以，最终得到的结果就是下图所示的样子了，如果说这个时候你的伪元素是用来放 icon 的，可能需要定义大量的样式去覆盖。</p><img src="`+t+'" style="zoom:50%;"><p>这种情况也不是说没有办法解决，只要脱离了文档流就可以了不用受到 flex 弹性布局的影响了，所以，我们可以使用 <code>position: absolute;</code> 的方式来解决。当然啦，具体问题具体分析，还是要根据实际的使用场景来处理，现在只是跟大家提一下，当你的 <code>display</code> 属性值是 <code>flex</code> 或者 <code>inline-flex</code> 的时候，不要忘记伪元素也是 flex 容器的直系子元素，也是 flex 元素。</p>',43),m=[r];function v(k,f){return s(),e("div",null,m)}const b=n(u,[["render",v],["__file","display.html.vue"]]);export{b as default};
